05-241023  
松尾凜太朗  

`virtio.c`に全ての実装がある。  
`init_virtio` が初期化、MACアドレス取得、パケット送受信を全て行っている。


送信にあたってスライドだけではすぐに理解ができなかったvirtqの仕組みは以下である。
 - descriptor1つは、実際にデータを入れるバッファ1つに対応している
 - descriptor areaは使うdescriptorをとにかく入れておく場所である。以後はdescriptor areaの何番目に入っているかのindexで扱う  
   このエリアのサイズ(descriptorが何個入るか)がqueue sizeと呼ばれ、これはデバイス側で決まっている。ドライバはqueue sizeを読んで、それに従ったバッファを作らなければならない。(2.6.2)
 - available queueは、送信したいデータが入ったバッファを入れる場所である。`idx`がring bufferのヘッドで、`ring`が上記のindexを入れるバッファ本体である。  
  `ring`の長さはqueue sizeなので、(同じバッファを2つ入れたりしない限り)バッファが溢れることはない。(2.6.13)  
   恐らくデバイス側に「どこまで消費したか」を表すtailのポインタもあるが、見えないようになっている。(そしてバッファが溢れることはないからドライバ側からすればtailはどうでもよい)  
 - used queueは、デバイスが処理済みのバッファを吐き出す場所である。こちらは逆に「ring bufferのどこまで読んで再利用に回したか」はドライバ側が内部変数として持っておくことになる。  
    今回の実装では1パケット送信すればよいのでused queueは扱っていない。

送信時に行うのは以下のことである

 - 仕様書のサンプルコードに従って送信用の`virtq`を用意する(`virtq_tx`)  
   `virtq`はスライドのように32-bit空間内の0x1000-alignedな場所に確保する。  
   仕様書の以下の各箇所にサンプルコードがある。ただし、queue sizeが動的なので各structのメンバアクセスはマクロでqueue sizeを使いながら行っている。例えば`VIRTQ_AVAIL(virtq)`は`virtq->avail`に相当する。
   - `virtq`: 2.6.2
     `ALIGN` の定義が意味不明なので、自分で考えて定義する。
   - `virtq_desc`: 2.6.5
   - `virtq_avail`: 2.6.6
   - `virtq_used`: 2.6.8
 - 送信データを入れるバッファ(0x1000-aligned)を用意する(`tx_buffer`)
 - 送信データを入れる。(`send_packet`前半)  
   送信データはvirtio用のヘッダ、ethernetのパケットヘッダ、本データからなる。それぞれ`virtio_net_hdr`, `ethernet_frame`型で表されている。
   送信元MACアドレスは課題Aで取得したもの、また今回ブロードキャストパケットを作るので送信先macアドレスはFF:...にする。typeは1536未満であればペイロード長を表すのに使うことができるので今回この使い方をした。
   `virtio_net_hdr`のメンバはスライドにある通りおおむね0でよい。`csum_start`や`csum_offset`は指定範囲のチェックサムをとるためのものだが、両方0にして無効化している。
   最小ペイロード長は46 Bであるから、それより長い送信文を選んだ。
 - そのバッファを表すdescriptorを作り、descriptorをvirtqのdescriptor areaの0番に入れる。さらにそのindex=0をavailable queueに入れ、デバイスに通知する。(`send_packet`後半)  
   descriptorの`len`に入れた長さだけ送られる。

